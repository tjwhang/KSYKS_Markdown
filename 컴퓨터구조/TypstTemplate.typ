#import "@preview/physica:0.9.4": *
#import "@preview/ilm_custom:1.4.1": *
#import "@preview/alchemist:0.1.4": *
#import "@preview/theorion:0.3.2": *
#import "@preview/rich-counters:0.2.1": *
#import "@preview/cetz:0.3.4": *
#import "@preview/cetz-plot:0.1.1": *
#import cosmos.rainbow: *

// 표지
#let title = [컴퓨터 구조와 작동 원리]

#show: ilm.with(
  title: title,
  author: "원작 Irv Englander, Wilson Wong\n번역 Taejoon Whang",
  date: datetime(year: 2025, month: 04, day: 03),
  abstract: [#lorem(30)],
  preface: align(horizon)[
    = 스스로 작동하는 냅킨
    교수는 잠결에 걷다가 맨발로 가시로 뒤덮인 선인장을 밟고, 스스로 작동하는 냅킨에 대한 이이디어를 떠올리며 소리를 내지른다.

    수프를 한 숟가락(A)을 떠 입으로 가져가면,(A)가 입으로 올라가면서 줄(B)를 당기고, 이로 인해 국자(C)가 움직이며 크래커(D)를 앵무새(E) 옆으로 던진다. 앵무새는 크래커를 쫓아 뛰어오르고 횃대(F)가 기울어져 씨앗(G)를 양동이(H)에 쏟아붓는다. 양동이에 가중된 무게가 줄(I)을 당겨 라이터(J)를 열고 점화시키며, 이는 폭죽(K)에 불을 붙여 낫(L)이 줄(M)을 자르게 한다. 이로 인해 냅킨이 부착된 진자가 앞뒤로 흔들리며 턱을 닦는다.

    식사 후에는 냅킨 대신 하모니카를 장착하여 소소한 음악으로 손님들을 즐겁게 해줄 수 있다.

    \_루브 골드버그 장치
    
  ],
  //bibliography: bibliography(""),
  figure-index: (enabled: false),
  table-index: (enabled: false),
  listing-index: (enabled: false)
)

#set text(font: (
  (
    name: "Source Han Serif K",
    covers: "latin-in-cjk",
  ),
  "Source Han Serif K"
),
cjk-latin-spacing: none,
weight: "medium"
)
#show math.equation: set text(font: "STIX Two Math")
#set math.equation(numbering: "(1.1)", supplement: [식. ])
#set outline()
#show raw: set text(font: ("JetBrains Mono", "D2Coding"))
#set page(
  paper: "a4",
  margin: 3.5cm,
  header: align(right, title),
  numbering: "1",
)
#set math.equation(numbering: none)

#let tag(content) = {
  math.equation(
    block: true, 
    numbering: "(1.1)", supplement: [식. ],
    content
  )
}

// 컴포넌트

#show: show-theorion

// #show: great-theorems-init

// #let mathcounter = rich-counter(
//   identifier: "mathblocks",
//   inherited_levels: 1
// )

// #let theorem = mathblock(
//   blocktitle: "Theorem",
//   counter: mathcounter,
// )

// #let lemma = mathblock(
//   blocktitle: "Lemma",
//   counter: mathcounter,
// )

// #let corollary = mathblock(
//   blocktitle: "Corollary",
//   counter: mathcounter,
// )

// #let definition = mathblock(
//   blocktitle: "Definition",
//   counter: mathcounter,
// )

// #let remark = mathblock(
//   blocktitle: "Remark",
//   prefix: [_Remark._],
//   inset: 5pt,
//   radius: 5pt,
// )

// #let proof = proofblock()

#set math.mat(delim: "[")

// 본문

= 서문
요즘 세상에서는 학습을 위한 온라인 자료를 즉시 찾아볼 수 있습니다. 위키백과, 구글, 뉴스, 수많은 웹사이트와 블로그, 유튜브까지도 여러분의 호기심과 흥미를 자극하는 거의 모든 주제에 관한 정보에 접근할 수 있게 합니다. 그럼에도, 우리는 여전히 무언가에 대한 깊은 이해를 하기 위해서는 옛날 방식 그대로, 종이에 인쇄된 책이 필요하다고 믿고는 합니다. 

어떤 주제에 관한 책이던 간에, 일반적으로 책을 처음 열면 생각해 볼 것은 이 책이 다루는 내용은 무엇이고 이 책이 읽을 가치가 있는가입니다. 나는 여기서 여러분이 들고 있는 이 책에 대해 그 질문을 해결해 주려고 합니다.

정보 시스템과 기술 분야는 정말 환상적인 곳입니다!

= 컴퓨터와 시스템


== 컴퓨터와 시스템

=== 도입
기술이 매일 변하는 현대 컴퓨터의 세계에 오신 것을 환영합니다. 그런데, 정말 현대 컴퓨터는 기술이 매일 변화할까요?

오늘날의 컴퓨터는 5년 또는 10년 전 컴퓨터와 전혀 다른 모습을 하고 있다는 것은 사실입니다. 오늘날 컴퓨터와 컴퓨터 기반 시스템 및 장치의 즉각적이고 편재적인 영향에서 벗어나는 것은 거의 불가능합니다. 아마도 당신의 주머니나 책상 위에는 스마트폰이 있을 것입니다. 많은 분들은 이 단락을 읽으면서 노트북이나 태블릿이 근처에 있을 것입니다. (아니면 태블릿이나 전자책에서 이 단락을 읽고 계실 수도 있습니다.) 게다가, 당신의 스마트폰은 아마도 10년 전 시장에 나온 대부분의 컴퓨터보다 더 많은 컴퓨팅 파워를 가지고 있습니다. 주머니나 지갑에 쉽게 들어갑니다. 과거의 데스크톱 컴퓨터 무게의 1/100도 안 되지만 메모리는 적어도 10배 이상입니다!

그게 다가 아닙니다. 당신의 자동차는 여러 자동차 기능을 제어하는 몇 개의 내장 컴퓨터와 아마도 핸즈프리 전화, 내비게이션, 라디오, 인터넷 접속 등을 위한 터치스크린을 갖추고 있습니다. 이것은 거의 불필요할 수도 있는데, 아마도 당신은 원하는 것을 구두로 말할 수 있기 때문입니다. 심지어 전자레인지와 빨래를 세탁하는 기계도 작동하기 위해 컴퓨터에 의존합니다. 아시다시피 이러한 대부분의 기계는 블루투스, 인터넷 또는 기타 네트워킹 기술을 사용하여 서로 통신할 수 있습니다. (IoT, 사물 인터넷을 한 예로 생각해보세요.) 재미로, 그림 1.1은 최근 노트북, 2020년 스마트폰, 그리고 자동차의 많은 기능을 제어하는 현재의 내장 컴퓨터의 전형적인 이미지를 보여줍니다.

이 책의 초점은 IT 시스템에 있지만, 컴퓨터 하드웨어, 소프트웨어 및 네트워킹에 대한 우리의 논의는 직장 컴퓨터, 태블릿, 스마트폰, 심지어 다른 장치 및 장비에 내장된 컴퓨터에도 동일하게 적용됩니다. 이 그림에서는 다른 유형의 애플리케이션에서 작동하는 세 가지 외관상 매우 다른 장비가 있습니다. 그럼에도 불구하고, 이 세 시스템이 많은 공통점을 공유한다는 것은 분명합니다. 모두 컴퓨터 기반입니다. 모두 최소한 하나의 중앙 처리 장치(CPU, 일부는 더 많이 포함)와 메모리를 포함합니다. 모두 장기 저장소 및 기타 장치, 그리고 사용자와 상호 작용할 수 있는 시설을 제공합니다. 덜 명확할 수 있는 것은 이들이 실행하는 프로그램도 기본적으로 유사하며, 주로 특정 시스템의 다른 구성 요소와 애플리케이션의 성격에 따라 필요한 세부 사항이 다르다는 점입니다. 예를 들어, 시스템은 다른 양의 메모리, 다른 유형의 디스플레이, 다른 I/O 장치 및 다른 운영 체제를 가질 수 있으며, 다른 유형의 애플리케이션을 실행하고 다른 목적을 제공합니다.

사실, 현대 IT 시스템은 많은 다른 유형의 시스템 요소를 포함할 수 있으며, 모든 것을 연결하는 네트워킹이 있습니다.

IT 시스템을 만들 때, 우리의 관심사는 다양한 구성 요소가 사용자가 요구하는 기능과 성능을 제공하는지 여부입니다. 효과적인 설계자와 사용자가 되기 위해서는 규격, 그 중요성과 의미, 용어, 그리고 전문 용어를 이해해야 합니다. 사용자에게 어떤 기능이 중요한가요? 원하는 작업을 수행하기 위해 컴퓨터에 필요한 적절한 기능 조합인가요? 필요한 기능이 빠진 것이 있나요? 아마도 우리가 필요한 성능에 비해 너무 많은 비용을 지불하고 있을 수도 있습니다. 또는 더 많이 필요할 수도 있습니다. 이 시스템에 대해 어떤 추가 정보가 더 정보에 입각한 결정을 내리는 데 도움이 될까요? 대부분의 현대 컴퓨터 기반 시스템을 적절히 운영하기 위해 내부 작동 방식을 이해할 필요는 분명히 없습니다. 실제로, 많은 경우에 컴퓨터의 존재는 우리에게 숨겨져 있거나 내장되어 있으며, 그 작동은 사용자로서 우리에게 보이지 않습니다. 전자책을 읽기 위해 컴퓨터가 어떻게 작동하는지 알 필요는 없습니다.

경험이 풍부한 사용자로서도, 우리는 개인용 컴퓨터에서 표준 소프트웨어 패키지를 실행하거나 스마트폰에서 앱을 실행할 때 정확히 어떻게 작동하는지 이해하지 않고도 할 수 있습니다. 우리는 기계가 개별 명령을 어떻게 실행하는지에 대한 세부 사항을 이해하지 않고도 고급 언어나 스크립팅 언어로 컴퓨터를 프로그래밍할 수 있습니다. 우리는 웹 브라우저가 웹 서버에서 페이지를 어떻게 가져오는지 또는 웹 서버가 그러한 페이지를 어떻게 생성하는지 이해하지 않고도 웹 페이지를 설계하고 구현할 수 있습니다. 우리는 시스템 사양을 이해하지 않고도 판매원으로부터 태블릿이나 노트북 컴퓨터를 구매할 수 있습니다.

그럼에도 불구하고, 무언가 빠져 있습니다. 아마도 소프트웨어가 우리가 원하는 것을 정확히 수행하지 않을 수 있고, 소프트웨어의 옵션을 조작하는 위험을 감수할 만큼 기계를 충분히 이해하지 못할 수 있습니다. 아마도 시스템을 더 잘 이해했다면, 프로그램을 더 빠르고 효율적으로 작성하고 구성했을 수도 있습니다. 아마도 더 빠르게 로드되고 더 잘 작동하는 웹 페이지를 만들 수 있었을 것입니다. 아마도 판매원이 우리의 업무에 최적의 시스템을 판매하지 않았을 수도 있습니다. 또는 단순히 흥분의 감각이 부족한 것일 수도 있습니다. 하지만 그것도 중요합니다!

여러분이 이 책을 읽는 이유는 컴퓨터 전문가가 되기 위해 공부하는 학생이거나, 아니면 단순히 컴퓨터가 무엇인지에 대해 더 깊은 이해를 원하는 사용자이기 때문입니다. 어느 경우든, 여러분은 앞으로의 삶에서 어떤 형태로든 컴퓨터 시스템과 상호 작용할 것을 알고 있습니다. 업계의 도구에 대해 뭔가를 아는 것은 좋을 뿐만 아니라 유용합니다. 더 중요한 것은, 컴퓨터 시스템의 작동을 이해하는 것이 즉각적인 이점이 있다는 것입니다: 그것은 여러분이 기계를 더 효과적으로 사용할 수 있게 해줄 것입니다.

사용자로서, 여러분은 컴퓨터 시스템의 능력, 강점, 그리고 한계에 대해 더 잘 알게 될 것입니다. 여러분이 사용하는 명령에 대해 더 잘 이해하게 될 것입니다. 여러분이 사용하는 프로그램 애플리케이션의 작동 중에 일어나는 일을 이해하게 될 것입니다. 컴퓨터 장비와 애플리케이션 프로그램에 대해 더 정보에 입각한 결정을 내릴 수 있게 될 것입니다. 운영 체제가 무엇인지, 그리고 어떻게 효과적으로 그리고 여러분에게 유리하게 사용하는지 더 명확하게 알게 될 것입니다. 작업을 수동으로 수행하는 것이 언제 바람직한지, 그리고 언제 컴퓨터를 사용해야 하는지 알게 될 것입니다. "온라인"으로 가는 가장 효율적인 방법과 홈 네트워크에서 얻을 수 있는 이점을 이해하게 될 것입니다. 시스템 분석가, 프로그래머, 그리고 다른 컴퓨터 전문가들과 의사소통하는 능력이 향상될 것입니다. 심지어 돈을 절약할 수도 있습니다! 매월 모바일 폰에서 50GB의 다운로드 데이터에 비용을 지불할 필요가 정말로 있나요? 그리고 그 50GB는 무엇에 사용되고 있나요?

프로그래머로서, 더 나은 프로그램을 작성할 수 있게 될 것입니다. 기계의 특성을 활용하여 프로그램이 더 효과적으로 작동하도록 할 수 있을 것입니다. 예를 들어, 변수에 적절한 데이터 타입을 선택하면 훨씬 더 빠른 성능을 얻을 수 있습니다. 곧 이것이 왜 그런지, 그리고 어떻게 적절한 선택을 하는지 알게 될 것입니다.

인덱스 변수가 반대로 되면 중첩된 루프를 훨씬 더 빠르게 처리하는 컴퓨터가 있다는 것을 발견하게 될 것입니다. 아마도 놀라운 아이디어일 수 있지만, 이것이 왜 사실인지 이해하게 될 것입니다.

C++와 같은 컴파일된 언어로 작성된 프로그램이 BASIC과 같은 해석된 프로그램 언어나 JavaScript와 같은 스크립팅 언어로 작성된 것보다 일반적으로 훨씬 빠르게 실행되는 이유를 이해하게 될 것입니다. 마찬가지로, 프로그램의 기본 레이아웃이 프로그램의 실행 시간 효율성에 큰 영향을 미칠 수 있는 이유를 알게 될 것입니다.

시스템 설계자 또는 시스템 분석가로서, 여러분은 선택한 구성 요소의 비용과 능력의 차이가 조직에 상당한 영향을 미칠 수 있음을 인식하면서 조직의 정보 기술(IT) 요구를 충족시키는 시스템의 설계와 구현을 담당하게 될 것입니다. 여기서 얻은 지식으로 특정 작업에 적합한 컴퓨터 시스템 구성 요소와 시스템 아키텍처 세트를 결정하고 정당화하며, 다른 가능한 시스템 아키텍처와의 절충점을 결정할 수 있는 더 나은 위치에 있게 될 것입니다.

시스템 전략에 대한 지능적인 결정을 내리는 데 경영진을 지원할 수 있게 될 것입니다: 회사가 웹 서버를 위해 대형 메인프레임/가상 머신 시스템 접근 방식을 채택해야 할까요, 아니면 기성품 블레이드 서버의 네트워크로 구성된 시스템이 더 낮은 비용으로 더 나은 성능을 제공할까요? 사용자의 요구를 충족시키기 위한 적절한 시설을 제공하는 최상의 방법을 분석할 준비가 더 잘 되어 있을 것입니다. 빠르게 변화하는 기술의 시대에, 조직의 요구 사항에 크게 영향을 미치지 않는 단순한 기술적 구식화와 오래된 장비를 교체할 실제 필요성을 시사하는 주요 발전을 구별할 수 있게 될 것입니다. 클라우드 및 기타 원격 서비스 사용에 내재된 절충점을 이해하게 될 것입니다.

컴퓨터를 선택할 때, 조직의 애플리케이션과 사용자의 요구를 가장 잘 충족시키는 컴퓨터와 서비스를 구매하고 싶을 것입니다. 다양한 대안을 비교하고 시스템을 사용자의 요구에 맞추기 위해 기술 사양을 읽고 이해할 수 있어야 합니다. 이 책은 시스템을 지능적으로 명시하고 구매하기 위해 알아야 할 것을 가르쳐 줄 것입니다. 다양한 CPU 기술 간의 차이점과 각각의 장단점을 알게 될 것입니다. 조직의 파일에 적합한 주변 하드웨어와 다양한 파일 시스템 형식 간의 절충점, 인트라넷을 구축하는 데 필요한 것, 그리고 특정 시스템의 속도, 크기, 성능 제한이 무엇인지 배우게 될 것입니다. macOS, Windows, Chrome OS, 그리고 Linux의 기능을 지식적으로 비교하고 어떤 것이 여러분에게 중요한지 결정할 수 있게 될 것입니다. 모바일 IT, 새로운 네트워크 프로토콜, 가상 머신 및 클라우드 서비스와 같은 새로운 기술과 개념에 컴퓨터에 대한 기본적인 이해를 적용할 수 있게 될 것입니다. 컴퓨터 판매원이 사용하는 전문 용어를 이해하고 그들의 판매 주장의 타당성을 판단하는 법을 배우게 될 것입니다.

네트워킹 전문가로서, 컴퓨터 시스템을 연결하고 외부 세계에 필요한 인터페이스를 제공하는 네트워크의 설계, 유지 관리, 지원 및 관리를 담당합니다. 장비와 네트워크 자원을 최적화하는 네트워크 레이아웃을 지정할 수 있어야 합니다. 기본 네트워크 구성과 프로토콜에 대한 이해를 통해 효율적인 방식으로 사용자에게 충분하고 적절한 접근을 제어하고 제공할 수 있습니다. 이 텍스트는 네트워킹 경력을 준비하기 위한 출발점으로 기본 도구를 제공합니다.

웹 서비스 설계자로서, 웹 시스템 구성, 페이지 디자인, 데이터 형식 지정 및 스크립팅 언어 선택, 보안 기능, 그리고 운영 체제를 최적화하여 고객이 웹 서비스에 접근하기 쉽게 하기 위한 지능적인 결정을 내릴 수 있어야 합니다.

시스템 관리자 또는 매니저로서, 여러분의 임무는 시스템의 가용성과 효율성을 최대화하는 것입니다. 시스템이 생성한 보고서를 이해하고 그 보고서의 정보를 사용하여 시스템 성능을 최적화하기 위한 변경을 할 수 있어야 합니다. 추가 자원이 언제 필요한지 알고, 적절한 선택을 지정할 수 있어야 합니다. 운영 체제 매개변수를 지정하고 구성하고, 파일 시스템을 설정하고, 클라우드 서비스를 선택하고, 빠르게 변화하는 환경에서 시스템 및 사용자 PC 업그레이드를 관리하고, 네트워크를 재구성하고, 시스템 보안 및 데이터 백업의 견고성을 제공하고 보장하며, 다른 많은 시스템 관리 작업을 수행해야 합니다. 대형 시스템의 구성은 매우 도전적일 수 있습니다. 이 텍스트는 시스템의 효과적인 관리에 필수적인 운영 체제 도구에 대한 이해를 제공할 것입니다.

간단히 말해서, 이 책을 완료하면 컴퓨터 하드웨어와 소프트웨어가 무엇인지, 그리고 프로그램과 데이터가 컴퓨터 시스템과 어떻게 상호 작용하는지 이해하게 될 것입니다. 컴퓨터 시스템을 구성하는 데 필요한 컴퓨터 하드웨어, 소프트웨어, 통신 구성 요소와 시스템에서 각 구성 요소의 역할이 무엇인지 이해하게 될 것입니다.

사용자로서 컴퓨터와 상호 작용할 때 컴퓨터 내부에서 일어나는 일에 대해 더 잘 이해하게 될 것입니다. 더 효율적인 프로그램을 작성할 수 있게 될 것입니다. 컴퓨터 시스템의 다양한 구성 요소의 기능을 이해하고 필요한 컴퓨터 장비와 자원을 의미 있는 방식으로 지정할 수 있게 될 것입니다. 시스템 관리자 또는 웹 서비스 또는 네트워크 설계자로서 가지고 있는 옵션을 이해하게 될 것입니다.

기술이 극도로 빠르게 변화하는 시대에, 컴퓨터 시스템의 아키텍처는 지난 60년 동안 약간만 변화하고 점진적으로 변화한 견고한 기반 위에 있습니다. 컴퓨터 시스템 아키텍처의 기초를 이해하면 기술적 변화와 함께 편안하게 흐르고 변화가 만드는 개선과 충족시키는 요구 사항의 맥락에서 변화를 이해할 수 있게 됩니다. 실제로, 전 학생들과 IT 임원 및 기타 IT 전문가들과의 인터뷰는 여기서 제시된 기본 개념에 대한 깊은 이해가 정보 기술 및 IT 관리 분야에서의 장기적인 생존과 성장에 기본적이라는 것을 명확하게 보여줍니다.

이러한 유형의 이해는 유능하고 성공적인 시스템 분석가, 시스템 아키텍트, 시스템 관리자, 또는 프로그래머가 되는 데 있어 매우 기본적입니다. 자동차를 운전하기 위해 자동차 엔진의 작동 방식을 이해할 필요는 없을 수 있지만, 최고급 경주용 자동차 운전자는 엔진을 철저히 알고 있으며 그것을 사용하여 경주에서 승리할 수 있다는 것을 확신할 수 있습니다. 전문 경주용 자동차 운전자처럼, 우리의 의도는 여러분이 컴퓨터 엔진을 효과적으로 사용하여 컴퓨터를 성공적으로 사용하는 데 도움을 주는 것입니다. 일반적인 최종 사용자는 컴퓨터 시스템이 어떻게 작동하는지에 대해 신경 쓰지 않을 수 있지만, 여러분은 그렇지 않습니다.

이것이 이 책의 목표입니다. 그럼 시작해 봅시다!

=== 시작점
컴퓨터 시스템의 아키텍처에 대한 자세한 공부를 시작하기 전에, 컴퓨터 시스템 설계와 운영을 안내하는 몇 가지 기본 원칙, 특성 및 요구 사항을 간략하게 살펴보겠습니다. 여기서 설명하는 기본 사항은 가장 작은 내장 장치부터 가장 큰 메인프레임 컴퓨터까지 크기나 목적에 관계없이 컴퓨터 전반에 적용됩니다.

간단한 시나리오에서, 여러분은 태블릿, 노트북 또는 데스크톱 개인용 컴퓨터를 사용하여 문서를 워드 프로세싱합니다. 아마도 마우스나 스타일러스 펜 또는 손가락과 같은 포인팅 장치를 사용하여 문서 내에서 이동하고 워드 프로세서 소프트웨어 애플리케이션의 기능을 제어하며, 키보드나 터치 스크린을 사용하여 문서 텍스트 데이터를 입력하고 수정합니다. 워드 프로세서 애플리케이션 프로그램은 문서와 함께 화면에 표시됩니다. 궁극적으로, 프린터로 문서를 인쇄할 수도 있습니다. 문서는 SSD(솔리드 스테이트 드라이브), 디스크, 플래시 드라이브 또는 다른 저장 장치에 저장합니다.

일반적인 컴퓨터 시스템의 기본은 이 간단한 예에서 쉽게 드러납니다. 포인팅 장치의 움직임과 클릭, 그리고 텍스트 데이터 입력은 시스템에 입력을 나타냅니다. 컴퓨터는 입력을 처리하고 화면에, 그리고 아마도 프린터에 출력을 제공합니다. 컴퓨터 시스템은 또한 일반적으로 SSD나 하드 디스크와 같은 일종의 저장 매체를 제공하여 텍스트를 미래 접근을 위해 저장합니다. 가장 간단한 용어로, 컴퓨터는 사용자로부터 입력을 받아 처리하고 화면에 결과를 출력합니다. 입력은 명령과 데이터 형태로 이루어집니다. 명령과 프로그램은 컴퓨터에게 데이터를 어떻게 처리할지 알려줍니다.

이제 두 번째, 약간 더 복잡한 예를 고려해 봅시다. 이 예에서 여러분의 작업은 인터넷에서 웹 페이지에 접속하는 것입니다. 다시, 컴퓨터에 대한 입력은 키보드와 포인터 제어 장치를 통해 이루어집니다. 그러나 웹 페이지 URL을 입력하면, 여러분의 컴퓨터는 웹 서버 소프트웨어가 있는 다른 컴퓨터에 메시지를 보냅니다. 그 컴퓨터는 차례로 웹 페이지 파일을 보내며, 이는 여러분의 컴퓨터의 브라우저에 의해 해석되어 화면에 표시됩니다. 아마도 웹 메시지 교환의 표준으로 하이퍼텍스트 전송 프로토콜(HTTP)이 사용된다는 것을 이미 알고 계실 것입니다.

이 예의 요소들은 첫 번째 예와 약간만 다릅니다. 명령 입력은 컴퓨터의 웹 브라우저 소프트웨어 애플리케이션에 어떤 처리가 이루어져야 하는지 알려줍니다; 이 경우, 웹 페이지에 접속하고자 하는 요구입니다. 컴퓨터의 출력은 원격 컴퓨터의 웹 서버에 웹 페이지를 나타내는 데이터를 요청하는 메시지입니다. 컴퓨터는 네트워크에서 데이터를 입력으로 받고, 웹 브라우저는 데이터를 처리하여 화면에 웹 페이지 출력을 표시합니다. 그림 1.2는 이 예의 레이아웃을 보여줍니다.

이 예와 첫 번째 예의 주요 차이점은 입력 데이터의 소스와 두 번째 예가 두 컴퓨터 간의 네트워크 연결을 필요로 한다는 사실입니다. 키보드 대신, 웹 브라우저가 처리할 입력 데이터는 통신 채널에서 옵니다. (이 논의에서는 채널의 정확한 성격이 중요하지 않습니다.) 두 경우 모두, 컴퓨터는 처리할 데이터 입력과, 일반적으로 HTML이나 XML인, 데이터가 어떻게 처리되어야 하는지 결정하는 제어 입력을 받고, 처리를 수행하며, 출력을 제공합니다.

이 두 예에는 크거나 작은 모든 IT 시스템에서 발견되는 모든 핵심 요소가 포함되어 있습니다.

- IT 시스템은 하나 이상의 컴퓨터 시스템으로 구성됩니다; 다중 컴퓨터 시스템은 일종의 네트워크 상호 연결을 사용하여 연결됩니다. 필연적으로, 네트워크 인터페이스는 컴퓨터 쌍 간의 메시지 교환 중에 양쪽 컴퓨터가 메시지를 이해할 수 있도록 *프로토콜*이라고 알려진 표준 협약을 준수해야 합니다. 네트워크 자체는 인터페이스 요구 사항이 충족되는 한 다양한 형태를 취할 수 있으며, 성능, 편의성, 비용과 같은 특성에 의해 결정됩니다.

- IT 시스템 내 개별 컴퓨터 시스템이 수행하는 작업은 입력, 처리, 출력으로 특징지을 수 있습니다. 이러한 특성화는 종종 그림 1.3에 표시된 *입력-처리-출력(IPO) 모델*로 표현됩니다. 저장 또한 이 모델 내에 표현됩니다. 또는, 저장은 미래 입력으로 사용하기 위해 저장될 출력으로 해석될 수 있습니다. 저장은 또한 수행될 처리 작업을 결정하는 소프트웨어 프로그램을 보관하는 데 사용됩니다. 임시, 단기 또는 장기적으로 프로그램과 데이터를 저장하는 능력은 시스템의 기본입니다. 2장 2.2절과 15장에서, 우리는 모든 IT 시스템이 단일 컴퓨터에서 복잡한 컴퓨터 집합체까지 모든 수준에서 동일한 기본 IPO 모델로 궁극적으로 특징지어질 수 있음을 보여줄 것입니다. 비록 대형 시스템의 복잡성이 모델을 모호하게 하고 실제 입력, 출력 및 처리 작업을 결정하기 더 어렵게 만들 수 있지만 말입니다. IPO 모델은 시스템 분석 및 설계 관행을 위한 중요한 기본 도구를 제공합니다.

- 개별 컴퓨터 시스템의 구성 요소는 처리 하드웨어, 입력 장치, 출력 장치, 저장 장치, 애플리케이션 소프트웨어 및 운영 체제 소프트웨어로 구성됩니다. 운영 체제 소프트웨어의 작업은 입력, 출력 및 파일 저장 기능의 관리를 포함하여 개별 시스템의 전반적인 제어를 제공하는 것입니다. 사용자와의 교환 수단과 더 큰 시스템 내의 컴퓨터 간 교환 수단은 데이터입니다. (두 번째 예에서 컴퓨터 간의 메시지는 데이터의 한 형태임을 주목하세요.) 그림 1.4는 더 큰 IT 시스템에 내장된 컴퓨터 시스템의 간단한 그림입니다.

그림 1.5는 컴퓨터 처리 중에 수행되는 기본 작업을 요약합니다. 이러한 작업은 차례로 프로그래밍 언어에 대한 이해에서 익숙한 기본 작업으로 축소될 수 있습니다. 고급 프로그래밍 언어에 공통적인 기본 처리 작업은 그림 1.6에 표시되어 있습니다.

=== 컴퓨터 시스템의 컴포넌트
앞 섹션에서 언급했듯이, 전산화된 입력-처리-출력 모델의 구현을 위해서는 세 가지 구성요소가 필요합니다:

1. *하드웨어* - 데이터를 입력하고 출력하는 물리적 메커니즘, 데이터를 조작하고 처리하는 기능, 그리고 다양한 입력, 출력, 저장 구성요소를 전자적으로 제어하는 기능을 제공합니다.

2. *소프트웨어* - 애플리케이션 및 시스템 소프트웨어로, 하드웨어에게 수행해야 할 정확한 작업과 그 순서를 지시하는 명령을 제공합니다.

3. 조작 및 처리되는 *데이터* - 이 데이터는 숫자일 수도 있고, 영숫자일 수도 있으며, 그래픽일 수도 있고, 다른 형태를 취할 수도 있지만, 모든 경우에 컴퓨터가 조작할 수 있는 형태로 표현되어야 합니다.

현대 시스템에서는 데이터 입력, 출력 표시, 그리고 처리에 사용되는 데이터와 소프트웨어의 저장이 실제 처리가 이루어지는 컴퓨터와 다른 위치에서 진행되는 경우가 많습니다. 많은 설치 환경에서 실제 처리는 컴퓨터 시스템 간에 분산되어 있으며, 특정 결과는 그것을 필요로 하는 개별 시스템으로 전달됩니다. 따라서 네 번째 구성요소도 고려해야 합니다:

통신 구성요소 - 상호 연결된 컴퓨터 시스템 간에 프로그램과 데이터를 전송하는 하드웨어와 소프트웨어로 구성됩니다.

하드웨어와 시스템 소프트웨어 구성요소는 컴퓨터 시스템의 아키텍처를 구성합니다. 통신 구성요소는 개별 컴퓨터 시스템을 연결하여 조직적 시스템 아키텍처를 형성합니다. 데이터 구성요소와 애플리케이션 소프트웨어는 컴퓨터 시스템 운영에 근본적이지만, 컴퓨터 시스템 아키텍처의 일부라기보다는 사용자나 공급업체가 컴퓨터 시스템에 제공하는 것입니다. (그러나 조직의 관점에서 아키텍처를 고려할 때 애플리케이션 소프트웨어와 데이터 구조가 전체 시스템 아키텍처의 일부로 간주되는 경우가 많습니다. 우리는 15장 15.3절에서 이 문제를 탐구합니다. 그러나 이 책의 초점은 주로 조직적 시스템 아키텍처보다는 컴퓨터 시스템 아키텍처에 있다는 점에 유의하세요.)

==== 하드웨어 컴포넌트
컴퓨터 시스템에서 가장 눈에 띄는 부분은 당연히 시스템을 구성하는 하드웨어입니다. 여러분이 프로그램을 작성하고 실행하는 컴퓨터 시스템을 생각해보세요. 프로그램 텍스트와 데이터 *입력* 및 컴퓨터 명령을 위해 키보드나 터치스크린, 포인팅 장치를 사용합니다. *출력*을 보기 위해 일반적으로 디스플레이 화면을 사용하고, 화면 출력의 대안으로 프린터를 자주 이용합니다. 이들은 모두 물리적 구성요소입니다.

프로그램의 계산 및 기타 작업은 컴퓨터 내부의 하나 이상의 *중앙처리장치(CPU)* 또는 "코어"에 의해 수행됩니다. 처리가 진행되는 동안 프로그램과 데이터를 저장하기 위한 *메모리*가 제공됩니다. SSD, 디스크, SD 플러그인 카드와 같은 다른 입출력 장치들은 프로그램과 데이터 파일의 장기 저장을 위해 사용됩니다. 데이터와 프로그램은 CPU가 사용할 수 있도록 다양한 입출력 장치와 메모리 사이에서 전송됩니다.

CPU, 메모리, 그리고 모든 입력, 출력 및 저장 장치는 컴퓨터 시스템의 *하드웨어* 부분을 형성합니다. 하드웨어는 시스템의 유형적 부분을 구성합니다. 그것은 물리적이며 - "유형적"이라는 단어의 의미처럼 손으로 만져볼 수 있습니다. 그림 1.7은 컴퓨터의 일반적인 하드웨어 블록 다이어그램을 보여줍니다. 이 다이어그램에 표시된 입출력 장치 외에도, 그림 1.8은 컴퓨터 시스템의 일부로 자주 볼 수 있는 다른 입출력 장치들을 나열합니다. 그림 1.7의 다이어그램은 대형 메인프레임 컴퓨터, 소형 개인용 컴퓨터, 휴대전화, 태블릿, 그리고 심지어 자동차, 스마트 초인종, 가정용 음성 인식 장치와 같이 컴퓨터가 내장된 장치들에도 동일하게 적용됩니다. 대형 및 소형 컴퓨터의 차이는 주로 코어 수, 메모리 용량, 속도, 용량 및 제공되는 입출력 장치의 선택에 있습니다. 기본적인 하드웨어 구성요소와 설계는 매우 유사합니다.

개념적으로, CPU 자체는 종종 세 가지 주요 하위 단위로 구성된 것으로 봅니다:
1. *산술/논리 장치(ALU)* - 산술 및 불리언 논리 계산을 수행하는 곳입니다.

2. *제어 장치(CU)* - 명령어 처리와 CPU 내부의 한 부분에서 다른 부분으로의 데이터 이동을 제어합니다.

3. *인터페이스 장치* - CPU와 다른 하드웨어 구성요소 간에 프로그램 명령어와 데이터를 이동시킵니다.

(현대 CPU에서는 기본 개념이 신중하게 보존되지만, 더 높은 성능을 달성하기 위해 실제 구현이 약간 수정됩니다. 이에 대해서는 8장에서 더 자세히 다룹니다.)

인터페이스 장치는 CPU를 메모리 및 다양한 I/O 모듈과 연결합니다. 또한 여러 CPU 코어를 함께 연결하는 데에도 사용할 수 있습니다. 많은 컴퓨터 시스템에서 버스는 CPU, 메모리 및 모든 I/O 구성요소를 상호 연결합니다. *버스*는 단순히 다른 구성요소 간에 신호와 전력을 전달하는 전선 묶음입니다. 다른 시스템에서는 I/O 모듈이 *채널*이라는 하나 이상의 별도 프로세서를 통해 CPU에 연결됩니다.

주 메모리는 종종 기본 저장장치, 작업 저장장치 또는 *RAM(Random Access Memory)*이라고 알려져 있으며, CPU가 접근할 수 있도록 프로그램과 데이터를 보관합니다. *주 저장장치*는 각각 번호가 매겨지고 개별적으로 주소 지정 가능한 많은 셀로 구성됩니다. 각 셀은 데이터 값의 일부 또는 명령어의 일부를 나타내는 단일 이진 번호를 저장합니다. 대부분의 현재 컴퓨터에서 가장 작은 주소 지정 가능한 셀의 크기는 메모리의 *바이트*라고 불리는 8비트입니다. 8비트의 메모리는 256개의 다른 패턴만 저장할 수 있으므로, 메모리의 인접한 셀은 거의 항상 더 많은 비트 수를 가진 그룹을 형성하기 위해 결합됩니다. 예를 들어, 많은 시스템에서 4바이트의 메모리가 결합하여 32비트 단어를 형성합니다. 현대 컴퓨터는 더 큰 명령어와 데이터 그룹을 활용하기 위해 최소 4바이트("32비트" 컴퓨터) 또는 8바이트("64비트" 컴퓨터)씩 메모리를 주소 지정합니다.

기본 저장장치의 양은 주변 장치에서 한 번에 메모리로 로드할 수 있는 최대 명령어 및 데이터 단어 수를 결정합니다. 예를 들어, 8기가바이트(GB), 실제로는 8,589,934,592바이트의 메모리를 가진 컴퓨터는 명령어와 데이터에 9.7GB가 필요한 프로그램을 실행할 수 없습니다. 단, 프로그램의 각 섹션이 필요할 때마다 섹션별로 로드하는 수단이 컴퓨터 내에 제공되지 않는 한 말입니다.

컴퓨터 기술이 향상됨에 따라 일반적인 컴퓨터에서 제공되는 기본 저장장치의 양은 빠르게 증가했습니다. 1980년에는 64킬로바이트(KB)의 메모리가 많은 양으로 간주되었지만, 오늘날 가장 저렴한 개인용 컴퓨터조차도 보통 8기가바이트(GB) 이상의 메모리를 가지고 있습니다. 대형 컴퓨터는 수많은 테라바이트의 기본 저장장치를 제공할 수 있습니다. 실행하기 위해 수백 메가바이트(MB) 또는 기가바이트(GB)의 메모리가 필요한 프로그램들이 시장에 있습니다. 저렴하게 증가된 메모리 양을 사용할 수 있게 됨으로써 불과 몇 년 전에는 불가능했을 매우 정교한 프로그램의 설계가 가능해졌습니다.

보조 저장장치에도 동일한 사실이 적용됩니다. 작은 개인용 컴퓨터조차도 수백 또는 수천 기가바이트 단위로 측정되는 하드 디스크나 솔리드 스테이트 저장 장치를 사용하여 장기 저장을 제공합니다. 특히 이미지와 비디오의 저장은 엄청난 양의 저장 용량을 필요로 합니다. 수십 또는 수백 조 바이트(테라바이트로 지정됨)의 장기 저장소를 제공하는 시스템을 보는 것은 드문 일이 아닙니다.

특정 프로그램을 구성하는 명령어는 기본 저장장치 내에 저장된 다음, CPU로 가져와서 실행됩니다. 개념적으로 명령어는 한 번에 하나씩 가져와서 실행되지만, 현대 시스템은 어느 정도 명령어 실행을 중첩시킵니다. 명령어가 실행되기 위해서는 기본 저장장치에 있어야 합니다. 제어 장치는 각 명령어를 해석하고 적절한 조치를 결정합니다.

각 명령어는 간단한 작업을 수행하도록 설계되었습니다. 기본 산술 연산을 수행하고, 컴퓨터 내의 한 곳에서 다른 곳으로 데이터를 이동시키고, I/O를 수행하고, 다른 많은 작업을 수행하는 명령어가 존재합니다. 컴퓨터의 힘은 초당 수십억 또는 수조 개의 명령어 실행으로 측정되는 매우 높은 속도로 이러한 간단한 명령어를 실행하는 능력에서 나옵니다. 이미 알고 계시듯이, 프로그램 실행을 위해 고수준 언어 프로그램을 기계 언어로 번역해야 합니다. 단일 고수준 언어 명령문에 해당하는 기계 언어를 형성하기 위해 수십, 수백 또는 심지어 수천 개의 개별 기계 명령어가 필요할 수 있습니다.

프로그램 명령어는 일반적으로 순차적으로 실행되며, 명령어 자체가 컴퓨터에게 처리 순서를 변경하라고 지시하지 않는 한 그렇습니다. 특정 CPU와 함께 사용되는 명령어 세트는 CPU 설계의 일부이며, 다른 CPU가 명령어 세트 호환성을 위해 설계되지 않은 한 일반적으로 다른 유형의 CPU에서 실행할 수 없습니다. 그러나 대부분의 명령어 세트는 비슷한 유형의 작업을 수행합니다. 결과적으로, 다른 명령어 세트를 가진 컴퓨터에서 한 컴퓨터의 명령어 세트를 *모방(emulate)*하는 프로그램을 작성하는 것이 가능합니다. 다만 원본 기계용으로 작성된 프로그램은 에뮬레이터가 있는 기계에서 더 느리게 실행될 수 있습니다.

이러한 명령어들이 조작하는 데이터도 처리되는 동안 메모리에 저장됩니다. 프로그램 명령어와 데이터가 처리되는 동안 모두 메모리에 저장된다는 개념은 *내장식 프로그램 개념(Stored Program Concept)*으로 알려져 있습니다. 이 중요한 개념은 주로 유명한 컴퓨터 과학자인 존 폰 노이만에게 기인합니다. 이것은 거의 모든 기존 컴퓨터에 표준인 컴퓨터 아키텍처의 기초를 형성합니다.